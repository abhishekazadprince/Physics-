<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="description" content="Structure-Preserving Time Evolution">
    <title>Structure-Preserving Time Evolution</title>
    <link rel="manifest" href="./manifest.json">
    
    <link rel="apple-touch-icon" href="https://img.icons8.com/color/192/atom-editor.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Physics">
    
    <!-- LIBRARIES -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- PDF GENERATION -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>

    <style>
        /* --- CORE RESET --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none;}
        :root { --bg: #000000; --accent: #06b6d4; --glass: rgba(10, 10, 18, 0.90); --border: rgba(255,255,255,0.15); }
        body { background: var(--bg); color: #e2e8f0; font-family: 'Inter', system-ui, sans-serif; height: 100dvh; width: 100vw; overflow: hidden; margin: 0; position: fixed; }
        
        /* LAYOUT & ANIMATION */
        #app-container { position: absolute; inset: 0; width: 100%; height: 100%; overflow: hidden; }
        .page { position: absolute; inset: 0; transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1); background: var(--bg); z-index: 10; display: flex; flex-direction: column; }
        .page.hidden-right { transform: translateX(100%); z-index: 20; }
        .page.hidden-left { transform: translateX(-30%); opacity: 0.5; }
        
        /* CANVAS */
        canvas { width: 100%; height: 100%; outline: none; display: block; touch-action: none;}
        
        /* UI ELEMENTS */
        .glass { background: var(--glass); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-top: 1px solid var(--border); }
        .glass-panel { background: rgba(255,255,255,0.03); border: 1px solid var(--border); border-radius: 0.5rem; }
        .btn-round { width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: rgba(255,255,255,0.08); border: 1px solid var(--border); transition: 0.2s; color: white; cursor: pointer; }
        .btn-round:active { transform: scale(0.9); background: var(--accent); color: black; }
        .stat-row { display: flex; justify-content: space-between; font-size: 9px; font-family: monospace; border-bottom: 1px solid rgba(255,255,255,0.05); padding: 4px 0; }
        .stat-lbl { opacity: 0.6; }
        .stat-val { color: var(--accent); }
        .disabled-overlay { position:absolute; inset:0; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; text-transform:uppercase; font-size:10px; font-weight:bold; letter-spacing:1px; color:#fff; z-index:50; backdrop-filter:blur(2px); }
        
        /* TAB SYSTEM */
        .tab-scroller { display: flex; overflow-x: auto; scrollbar-width: none; -ms-overflow-style: none; white-space: nowrap; mask-image: linear-gradient(to right, black 90%, transparent 100%); }
        .tab-scroller::-webkit-scrollbar { display: none; }
        .tab-btn { padding: 12px 16px; font-size: 10px; font-weight: 800; opacity: 0.5; transition: 0.2s; border-bottom: 2px solid transparent; letter-spacing: 0.05em; color: #94a3b8; }
        .tab-btn.active { opacity: 1; color: var(--accent); border-color: var(--accent); }
        
        /* SLIDERS */
        input[type=range] { -webkit-appearance: none; background: transparent; height: 24px; width: 100%; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: var(--accent); margin-top: -6px; box-shadow: 0 0 10px var(--accent); transition: transform 0.1s; }
        input[type=range]:active::-webkit-slider-thumb { transform: scale(1.3); }

        /* TEXT SECTIONS */
        .info-section h3 { color: var(--accent); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; font-weight: 800; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 2px; margin-top: 1rem; }
        .info-section p { font-size: 0.8rem; line-height: 1.6; opacity: 0.8; margin-bottom: 0.5rem; }
        .info-section li { font-size: 0.8rem; opacity: 0.7; list-style: disc; margin-left: 1rem; }

        /* UTILS */
        .safe-top { padding-top: max(16px, env(safe-area-inset-top)); }
        .safe-bottom { padding-bottom: max(32px, env(safe-area-inset-bottom)); }
        .spinner { border: 2px solid rgba(255,255,255,0.1); border-left-color: var(--accent); border-radius: 50%; width: 16px; height: 16px; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* CINEMA MODE */
        .cinema-mode #ui-layer, .cinema-mode #drawer { display: none !important; }
        .cinema-mode canvas { cursor: none; }
    </style>
</head>
<body>

<div id="app-container">
    
    <!-- === HOME SCREEN === -->
    <div id="page-home" class="page">
        <header class="p-6 safe-top bg-gradient-to-b from-slate-900 to-transparent border-b border-white/5 shrink-0">
            <div class="flex justify-between items-center">
                <div>
                    <h1 class="text-3xl font-black tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-indigo-500">FDE Lab</h1>
                    <p class="text-[10px] uppercase tracking-[0.3em] opacity-60 font-mono mt-1">Scientific Universe V25</p>
                </div>
                <i class="fas fa-atom text-4xl text-cyan-500/20 rotate-12"></i>
            </div>
        </header>
        
        <div class="flex-1 overflow-y-auto p-4 safe-bottom space-y-6" id="algo-list">
            <!-- Populated by JS -->
        </div>
    </div>

    <!-- === SIMULATION SCREEN === -->
    <div id="page-sim" class="page hidden-right">
        
        <!-- CANVAS -->
        <canvas id="simCanvas" class="absolute inset-0 z-0"></canvas>
        
        <!-- UI OVERLAY -->
        <div id="ui-layer" class="absolute inset-0 z-10 flex flex-col pointer-events-none">
            
            <!-- TOP BAR -->
            <div class="pointer-events-auto bg-gradient-to-b from-black/90 to-transparent p-4 safe-top flex items-center justify-between">
                <button onclick="App.goBack()" class="btn-round"><i class="fas fa-arrow-left"></i></button>
                <div class="text-center">
                    <div id="sim-title" class="text-[10px] font-black text-cyan-400 tracking-widest uppercase drop-shadow-lg">SIMULATION</div>
                    <div class="flex gap-2 justify-center items-center mt-1">
                        <span class="text-[8px] bg-white/10 px-1.5 py-0.5 rounded text-white/70 font-mono border border-white/5" id="sim-status">RUNNING</span>
                        <span id="rec-dot" class="hidden w-2 h-2 rounded-full bg-red-500 animate-pulse shadow-[0_0_8px_red]"></span>
                    </div>
                </div>
                <div class="flex gap-2">
                    <button onclick="App.toggleCinema()" class="btn-round text-yellow-400 border-yellow-500/30" title="Full Screen"><i class="fas fa-expand text-xs"></i></button>
                    <button onclick="App.togglePause()" id="play-btn" class="btn-round bg-cyan-600 border-none text-black shadow-lg shadow-cyan-500/20"><i class="fas fa-pause text-xs"></i></button>
                </div>
            </div>

            <!-- GESTURE HINT -->
            <div class="flex-1 flex items-end justify-center pb-8">
                <div id="gesture-hint" class="bg-black/60 backdrop-blur px-4 py-2 rounded-full border border-white/10 text-[10px] text-cyan-400 font-mono opacity-0 transition-opacity duration-500 flex items-center gap-2">
                    <i class="fas fa-hand-pointer"></i> <span>2-Finger Pan/Zoom • 1-Finger Orbit</span>
                </div>
            </div>
            
            <!-- TOAST -->
            <div id="toast" class="absolute top-20 left-1/2 -translate-x-1/2 bg-slate-800 text-white text-xs px-4 py-2 rounded-full shadow-2xl border border-white/10 opacity-0 transition-opacity pointer-events-none flex items-center gap-2 z-50">
                <i class="fas fa-info-circle text-cyan-400"></i> <span id="toast-msg"></span>
            </div>
        </div>

        <!-- DRAWER (Bottom Sheet) -->
        <div id="drawer" class="absolute bottom-0 left-0 right-0 z-20 pointer-events-auto flex flex-col h-[65dvh] transition-transform duration-300 translate-y-0 bg-slate-950/95 backdrop-blur-2xl border-t border-white/10 rounded-t-3xl shadow-[0_-10px_60px_rgba(0,0,0,0.7)]">
            
            <!-- HANDLE -->
            <div class="w-full h-7 flex items-center justify-center shrink-0 cursor-pointer active:opacity-50" onclick="App.toggleDrawer()">
                <div class="w-12 h-1 bg-white/20 rounded-full"></div>
            </div>

            <!-- TABS -->
            <div class="border-b border-white/10 shrink-0">
                <div class="tab-scroller px-2">
                    <button onclick="App.setTab('controls')" class="tab-btn active" data-tab="controls">CONTROLS</button>
                    <button onclick="App.setTab('numerics')" class="tab-btn" data-tab="numerics">NUMERICS</button>
                    <button onclick="App.setTab('phase')" class="tab-btn" data-tab="phase">PHASE</button>
                    <button onclick="App.setTab('poincare')" class="tab-btn" data-tab="poincare">MAP</button>
                    <button onclick="App.setTab('graph')" class="tab-btn" data-tab="graph">GRAPH</button>
                    <button onclick="App.setTab('bifur')" class="tab-btn" data-tab="bifur">BIFUR</button>
                    <button onclick="App.setTab('fft')" class="tab-btn" data-tab="fft">SPECTRUM</button>
                    <button onclick="App.setTab('data')" class="tab-btn" data-tab="data">DATA</button>
                    <button onclick="App.setTab('info')" class="tab-btn" data-tab="info">INFO</button>
                </div>
            </div>

            <!-- CONTENT AREA -->
            <div class="flex-1 overflow-y-auto p-5 pb-24 relative bg-black/10" id="drawer-content">
                
                <!-- 1. CONTROLS -->
                <div id="tab-controls" class="space-y-6">
                    <div class="glass-panel p-4 flex items-center justify-center min-h-[64px] relative overflow-hidden group">
                        <div class="absolute inset-0 bg-gradient-to-r from-cyan-500/5 to-purple-500/5 opacity-50"></div>
                        <div id="katex-eq" class="text-sm relative z-10 text-cyan-100"></div>
                    </div>

                    <div class="space-y-5">
                        <div class="control-group">
                            <div class="flex justify-between text-[10px] mb-2 opacity-80"><span class="font-bold uppercase tracking-wider text-cyan-400">Parameter K</span><span id="lbl-k" class="font-mono">0.50</span></div>
                            <input type="range" id="inp-k" min="0" max="1" step="0.01" value="0.5">
                        </div>
                        <div class="control-group">
                            <div class="flex justify-between text-[10px] mb-2 opacity-80"><span class="font-bold uppercase tracking-wider text-cyan-400">Delay / Freq</span><span id="lbl-tau" class="font-mono">20</span></div>
                            <input type="range" id="inp-tau" min="0" max="100" value="20">
                        </div>
                        
                        <div class="glass-panel p-4 space-y-4 border-l-2 border-yellow-500/50">
                            <div class="flex justify-between items-center">
                                <span class="text-[10px] font-bold text-yellow-500 uppercase"><i class="fas fa-cube mr-1"></i> 3D Visualization</span>
                                <input type="checkbox" id="inp-3d" class="accent-yellow-500 w-4 h-4 cursor-pointer">
                            </div>
                            <div class="grid grid-cols-2 gap-4">
                                <div><div class="text-[9px] opacity-60 mb-1">Tilt X</div><input type="range" id="inp-rotX" min="-90" max="90" value="0"></div>
                                <div><div class="text-[9px] opacity-60 mb-1">Zoom</div><input type="range" id="inp-zoom" min="0.1" max="5" step="0.1" value="1"></div>
                            </div>
                        </div>

                        <div id="preset-container" class="flex flex-wrap gap-2 pt-2"></div>
                        
                        <div class="grid grid-cols-2 gap-3 text-[10px] font-bold">
                            <button onclick="App.toggleAudio()" class="glass-panel p-3 text-left hover:bg-white/5 active:bg-white/10 flex items-center gap-2"><i class="fas fa-volume-up text-cyan-400"></i> Sonify Data</button>
                            <button onclick="App.toggleRec()" class="glass-panel p-3 text-left hover:bg-white/5 active:bg-white/10 flex items-center gap-2"><i class="fas fa-video text-red-400"></i> Record MP4</button>
                            <label class="glass-panel p-3 flex items-center gap-2 cursor-pointer"><input type="checkbox" id="inp-trail" checked class="accent-cyan-400"> Show Trails</label>
                            <label class="glass-panel p-3 flex items-center gap-2 cursor-pointer"><input type="checkbox" id="inp-glow" class="accent-cyan-400"> Glow FX</label>
                        </div>
                    </div>
                    
                    <div id="custom-panel" class="hidden space-y-3 pt-4 border-t border-white/10">
                        <div class="text-[9px] font-bold opacity-50 uppercase tracking-widest">Custom ODE Setup</div>
                        
                        <!-- System Type Selector for Locking -->
                        <div class="flex gap-2 mb-2">
                             <select id="sel-custom-type" class="w-full bg-black border border-white/20 rounded px-2 py-1 text-[10px] font-mono">
                                <option value="DISSIPATIVE">Dissipative (Chaos)</option>
                                <option value="HAMILTONIAN">Hamiltonian (Energy)</option>
                                <option value="DELAY">Delay (DDE)</option>
                            </select>
                        </div>

                        <textarea id="inp-code-custom" class="w-full bg-black/40 border border-white/10 rounded p-3 text-[10px] font-mono text-green-400 focus:border-cyan-500 outline-none resize-none h-24">
const x=s[0], y=s[1], z=s[2];
return [
  10*(y-x),
  x*(28-z)-y,
  x*y - (8/3)*z
];</textarea>
                        <button onclick="App.compileCustom()" class="w-full bg-cyan-600/20 text-cyan-400 border border-cyan-500/30 hover:bg-cyan-600/40 py-2 rounded text-[9px] font-bold tracking-widest transition">COMPILE & RUN</button>
                    </div>
                </div>

                <!-- 2. NUMERICS -->
                <div id="tab-numerics" class="hidden h-full space-y-6">
                    <!-- Controls -->
                    <div class="glass-panel p-4 space-y-4 relative">
                        <!-- Solver Lock Overlay -->
                        <div id="solver-lock-msg" class="hidden absolute top-0 right-0 bg-yellow-500/20 text-yellow-300 text-[8px] px-2 py-1 rounded-bl"></div>

                        <div class="flex justify-between items-center border-b border-white/10 pb-2">
                            <h3 class="text-[10px] font-bold text-cyan-400 uppercase tracking-widest">Integration Control</h3>
                            <div class="flex gap-1 text-[9px] font-mono">
                                <button onclick="App.setDirection(1)" id="btn-fwd" class="px-2 py-1 bg-cyan-600 rounded text-white">FWD</button>
                                <button onclick="App.setDirection(-1)" id="btn-bwd" class="bg-white/10 px-2 py-1 rounded">REV</button>
                            </div>
                        </div>
                        <div class="space-y-2">
                            <div class="flex justify-between text-[9px] font-mono opacity-80"><span>Step Size (dt)</span><span id="lbl-dt">0.050</span></div>
                            <input type="range" id="inp-dt" min="0.001" max="0.2" step="0.001" value="0.05">
                        </div>
                        <div class="space-y-2">
                             <div class="flex justify-between text-[9px] font-mono opacity-80"><span>Solver Method</span></div>
                             <select id="sel-solver" onchange="App.setSolver(this.value)" class="w-full bg-black border border-white/20 rounded px-2 py-1 text-[10px] font-mono">
                                <option value="RK4">RK4 (Fixed Step)</option>
                                <option value="RK45">RK45 (Adaptive Step)</option>
                                <option value="SYMP">Symplectic Euler (Order 1)</option>
                                <option value="VERLET">Velocity Verlet (Order 2)</option>
                                <option value="YOSHIDA">Yoshida (Order 4 Symplectic)</option>
                                <option value="CN">Crank-Nicolson (FD)</option>
                                <option value="SPLIT">Split-Operator (Spectral FFT)</option>
                                <option value="DDE">DDE (Hermite Cubic)</option>
                             </select>
                        </div>
                        <div class="space-y-2">
                            <div class="flex justify-between text-[9px] font-mono opacity-80"><span>Boundary Condition (Quantum)</span></div>
                             <select id="sel-bc" onchange="App.setBC(this.value)" class="w-full bg-black border border-white/20 rounded px-2 py-1 text-[10px]">
                                <option value="absorbing">Absorbing (CAP/PML)</option>
                                <option value="periodic">Periodic</option>
                                <option value="reflecting">Reflecting</option>
                            </select>
                        </div>
                        <div class="flex justify-between items-center pt-2 gap-2">
                            <label class="flex items-center gap-2 text-[9px] cursor-pointer"><input type="checkbox" id="chk-ghosts" class="accent-red-500" onchange="App.toggleGhosts()"> Comp. Ghosts</label>
                            <label class="flex items-center gap-2 text-[9px] cursor-pointer"><input type="checkbox" id="chk-flow" class="accent-blue-500" onchange="App.toggleFlow()"> Vector Field</label>
                        </div>
                         <button onclick="App.spawnEnsemble()" class="w-full bg-purple-600/20 text-purple-300 border border-purple-500/50 text-[9px] px-3 py-2 rounded hover:bg-purple-600/30 transition mt-2">SPAWN CHAOS ENSEMBLE (50)</button>
                    </div>

                    <!-- Diagnostics -->
                    <div class="glass-panel p-4 space-y-2">
                         <h3 class="text-[10px] font-bold text-red-400 uppercase tracking-widest border-b border-white/10 pb-2 mb-2">Error Diagnostics</h3>
                         
                         <div class="stat-row"><span class="stat-lbl">Active Solver</span><span id="diag-order" class="stat-val">RK4</span></div>
                         <div class="stat-row"><span class="stat-lbl">Step Size (dt)</span><span id="diag-dt" class="stat-val">0.050</span></div>
                         <div class="stat-row" id="row-div"><span class="stat-lbl">Jacobian Trace</span><span id="val-div" class="stat-val">...</span></div>
                         <div class="stat-row" id="row-lyap"><span class="stat-lbl">FTLE (Lyapunov)</span><span id="val-lyap" class="stat-val">0.00</span></div>
                         <div class="stat-row" id="row-norm"><span class="stat-lbl">Quantum Unitarity</span><span id="val-norm" class="stat-val">--</span></div>
                         <div class="stat-row" id="row-drift"><span class="stat-lbl">Energy Drift</span><span id="diag-drift" class="stat-val text-yellow-400">--</span></div>
                         <div class="stat-row"><span class="stat-lbl">Truncation Err</span><span id="diag-local" class="stat-val">Checking...</span></div>
                    </div>

                    <!-- Tools -->
                    <div class="grid grid-cols-2 gap-3">
                        <button onclick="App.runDtSweep()" class="glass-panel p-3 text-center hover:bg-white/5 active:bg-white/10">
                            <div class="text-[9px] font-bold text-cyan-400 mb-1">RUN DT SWEEP</div>
                            <div class="text-[8px] opacity-60">Check Convergence</div>
                        </button>
                        <button onclick="App.runReversibility()" class="glass-panel p-3 text-center hover:bg-white/5 active:bg-white/10">
                            <div class="text-[9px] font-bold text-purple-400 mb-1">REVERSIBILITY</div>
                            <div class="text-[8px] opacity-60">Fwd + Bwd Check</div>
                        </button>
                    </div>

                    <div id="sweep-result" class="hidden text-[9px] font-mono p-2 bg-black/40 rounded border border-white/10 text-center">
                        Wait for sweep...
                    </div>
                </div>

                <!-- 3. PHASE -->
                <div id="tab-phase" class="hidden h-full flex flex-col">
                    <div class="flex-1 glass-panel relative overflow-hidden border border-purple-500/30 bg-black">
                        <canvas id="phaseCanvas"></canvas>
                        <button onclick="App.clearCanvas('phaseCanvas')" class="absolute top-3 right-3 text-[9px] bg-black/50 px-2 py-1 rounded hover:bg-white/20 transition">CLR</button>
                        <!-- Disabled Overlay for Driven/Delay Systems -->
                        <div id="phase-disabled" class="disabled-overlay hidden">Disabled for Non-Autonomous System</div>
                    </div>
                    <div class="mt-3 glass-panel p-3 flex justify-between items-center text-[10px] font-mono">
                        <span>Projected: <span id="lbl-phase-proj" class="text-purple-400 font-bold">X vs Y</span></span>
                    </div>
                </div>

                <!-- 4. POINCARE -->
                <div id="tab-poincare" class="hidden h-full flex flex-col">
                    <div class="flex-1 glass-panel relative overflow-hidden border border-orange-500/30 bg-black">
                        <canvas id="poincareCanvas"></canvas>
                        <div class="absolute inset-0 flex items-center justify-center pointer-events-none opacity-20 text-[10px] uppercase font-bold tracking-widest">Stroboscopic Section</div>
                         <!-- Disabled Overlay -->
                        <div id="poincare-disabled" class="disabled-overlay hidden">Only for Driven Systems</div>
                    </div>
                </div>

                <!-- 5. GRAPH -->
                <div id="tab-graph" class="hidden h-full flex flex-col">
                    <div class="flex-1 glass-panel p-2 relative bg-black/20">
                        <canvas id="graphCanvas"></canvas>
                    </div>
                </div>

                <!-- 6. BIFURCATION -->
                <div id="tab-bifur" class="hidden h-full flex flex-col">
                    <div class="flex justify-between items-center mb-3">
                        <span class="text-[10px] font-bold text-green-400 uppercase tracking-wider">K-Sweep (Computed)</span>
                        <button onclick="App.runBifurcation()" class="bg-green-600 hover:bg-green-500 text-white text-[9px] px-4 py-1.5 rounded-full font-bold transition">COMPUTE SCAN</button>
                    </div>
                    <div class="flex-1 glass-panel relative border border-green-500/30 shadow-inner overflow-hidden bg-black">
                        <canvas id="bifurCanvas" class="absolute inset-0 w-full h-full"></canvas>
                        <div id="bifur-overlay" class="absolute inset-0 bg-black/90 flex flex-col items-center justify-center hidden z-10">
                            <div class="spinner mb-3"></div>
                            <div class="text-[9px] font-mono text-green-400">Computing Phase Space... <span id="bifur-prog">0%</span></div>
                        </div>
                    </div>
                </div>

                <!-- 7. FFT -->
                <div id="tab-fft" class="hidden h-full flex flex-col">
                    <div class="flex justify-between items-center mb-2">
                        <div class="text-[10px] font-bold text-pink-400">POWER SPECTRUM (DFT)</div>
                        <div class="text-[9px] font-mono opacity-60">Nyquist: <span id="lbl-nyquist" class="text-white">--</span> Hz</div>
                    </div>
                    <div class="flex-1 glass-panel p-3 relative border border-pink-500/30 flex items-end bg-black/20" id="fft-bars">
                         <!-- Bars injected here -->
                    </div>
                </div>

                <!-- 8. DATA -->
                <div id="tab-data" class="hidden h-full flex flex-col">
                    <div class="flex justify-end gap-2 mb-3">
                         <button onclick="App.exportCSV()" class="bg-blue-600/20 text-blue-300 border border-blue-500/50 text-[9px] px-3 py-1.5 rounded hover:bg-blue-600/30 transition">CSV</button>
                         <button onclick="App.exportPDF()" class="bg-red-600/20 text-red-300 border border-red-500/50 text-[9px] px-3 py-1.5 rounded hover:bg-red-600/30 transition">FULL PDF REPORT</button>
                    </div>
                    <div class="flex-1 glass-panel overflow-auto rounded-lg border border-white/5">
                        <table class="w-full text-[9px] font-mono text-left">
                            <thead class="bg-white/5 sticky top-0 text-cyan-400 backdrop-blur"><tr><th class="p-3">TIME</th><th>X_VAL</th><th>Y_VAL</th><th>Z_VAL</th><th>ERR</th></tr></thead>
                            <tbody id="data-body" class="divide-y divide-white/5 text-white/70"></tbody>
                        </table>
                    </div>
                    <div class="text-[8px] text-white/30 text-center mt-1">Showing preview. PDF contains detailed log.</div>
                </div>

                <!-- 9. INFO (FIXED & EXTENDED) -->
                <div id="tab-info" class="hidden h-full p-2">
                    <h2 id="info-heading" class="text-xl font-bold text-cyan-400 mb-4 border-b border-white/10 pb-2"></h2>
                    <div id="info-body" class="info-section">
                        <!-- Populated by JS -->
                    </div>
                </div>

            </div>
        </div>
    </div>
</div>

<script>
/* --- NUMERICS KERNEL --- */
const Physics = {
    // Basic FFT (Cooley-Tukey Radix-2)
    fft: (re, im, inv) => {
        const n = re.length;
        // Bit Reversal
        let j = 0;
        for (let i = 0; i < n - 1; i++) {
            if (i < j) {
                [re[i], re[j]] = [re[j], re[i]];
                [im[i], im[j]] = [im[j], im[i]];
            }
            let k = n >> 1;
            while (k <= j) { j -= k; k >>= 1; }
            j += k;
        }
        // Butterfly
        let step = 1;
        while (step < n) {
            const jump = step << 1;
            const deltaTheta = (inv ? -1 : 1) * Math.PI / step;
            const wReal = Math.cos(deltaTheta);
            const wImag = Math.sin(deltaTheta);
            for (let i = 0; i < n; i += jump) {
                let uReal = 1, uImag = 0;
                for (let k = 0; k < step; k++) {
                    const id = i + k + step;
                    const tReal = uReal * re[id] - uImag * im[id];
                    const tImag = uReal * im[id] + uImag * re[id];
                    re[id] = re[i + k] - tReal;
                    im[id] = im[i + k] - tImag;
                    re[i + k] += tReal;
                    im[i + k] += tImag;
                    // Rotation
                    const temp = uReal * wReal - uImag * wImag;
                    uImag = uReal * wImag + uImag * wReal;
                    uReal = temp;
                }
            }
            step = jump;
        }
        // Scaling for inverse
        if (inv) for (let i = 0; i < n; i++) { re[i] /= n; im[i] /= n; }
    },

    // Structure-Preserving Integrators
    project: (y, p) => {
        // Placeholder for SHAKE/RATTLE constraint projection
        // If system had explicit constraint g(q)=0, we would Lagrange multiplier correction here.
        if(p.constraints) { /* Apply geometric constraints */ }
        return y;
    },

    velocityVerlet: (t, y, dt, fn, p) => {
        const h = y.length/2;
        const q = y.slice(0, h);
        const v = y.slice(h);
        
        // 1. Get acceleration a(t)
        const s_t = [...q, ...v];
        const derivs = fn(t, s_t, p);
        const a_t = derivs.slice(h);

        // 2. q(t+dt) = q(t) + v(t)dt + 0.5*a(t)dt^2
        const q_next = q.map((val, i) => val + v[i]*dt + 0.5*a_t[i]*dt*dt);

        // 3. a(t+dt) using q_next. (Force depends on q mostly)
        // We use v as placeholder since conservative force usually F(q)
        const s_next_guess = [...q_next, ...v]; 
        const derivs_next = fn(t+dt, s_next_guess, p);
        const a_next = derivs_next.slice(h);

        // 4. v(t+dt) = v(t) + 0.5*(a(t) + a(t+dt))dt
        const v_next = v.map((val, i) => val + 0.5*(a_t[i] + a_next[i])*dt);
        
        const res = [...q_next, ...v_next];
        return Physics.project(res, p);
    },

    yoshida: (t, y, dt, fn, p) => {
        // 4th Order Symplectic Composition
        // w1 = 1 / (2 - 2^(1/3))
        const w1 = 1.3512071919596578;
        const w0 = -1.7024143839193153; // 1 - 2*w1
        
        const steps = [w1*dt, w0*dt, w1*dt];
        let curr = [...y];

        // Helper: Velocity Verlet Step (2nd Order Symplectic)
        const verletStep = (state, _dt) => Physics.velocityVerlet(t, state, _dt, fn, p);

        // Composition: S4 = S2(w1) o S2(w0) o S2(w1)
        for(let s of steps) {
            curr = verletStep(curr, s);
        }
        return curr;
    },

    // Tridiagonal Matrix Algorithm (TDMA) for Crank-Nicolson
    tdma: (a, b, c, d) => {
        const n = d.length;
        const c_prime = new Float32Array(n - 1);
        const d_prime = new Float32Array(n);
        
        c_prime[0] = c[0] / b[0];
        d_prime[0] = d[0] / b[0];
        
        for (let i = 1; i < n; i++) {
            let temp = 1.0 / (b[i] - a[i - 1] * c_prime[i - 1]);
            if (i < n - 1) c_prime[i] = c[i] * temp;
            d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) * temp;
        }
        
        const x = new Float32Array(n);
        x[n - 1] = d_prime[n - 1];
        for (let i = n - 2; i >= 0; i--) {
            x[i] = d_prime[i] - c_prime[i] * x[i + 1];
        }
        return x;
    },

    // Standard FD Crank-Nicolson
    crankNicolson: (t, psi, dt, p) => {
        const N = psi.length / 2;
        const Re = psi.slice(0, N);
        const Im = psi.slice(N, 2 * N);
        const dx = 1.0; 
        const C = 1.0 / (2 * dx * dx); 
        const alpha = dt / 2.0;

        const V = new Float32Array(N);
        const W = new Float32Array(N); 
        
        for(let i=0; i<N; i++) {
            V[i] = p.V; 
            if (p.bc === 'absorbing') {
                const width = 20;
                if (i < width) W[i] = 2.0 * Math.pow((width - i) / width, 2);
                else if (i > N - width) W[i] = 2.0 * Math.pow((i - (N - width)) / width, 2);
            }
        }

        const rhsRe = new Float32Array(N);
        const rhsIm = new Float32Array(N);

        for(let i=0; i<N; i++) {
            const imL = (i===0) ? (p.bc==='periodic'?Im[N-1]:0) : Im[i-1];
            const imR = (i===N-1) ? (p.bc==='periodic'?Im[0]:0) : Im[i+1];
            const reL = (i===0) ? (p.bc==='periodic'?Re[N-1]:0) : Re[i-1];
            const reR = (i===N-1) ? (p.bc==='periodic'?Re[0]:0) : Re[i+1];

            const termV_Re = (2*C + V[i])*Re[i] - C*(reL + reR);
            const termV_Im = (2*C + V[i])*Im[i] - C*(imL + imR);
            const termW_Re = W[i]*Re[i];
            const termW_Im = W[i]*Im[i];

            rhsRe[i] = Re[i] + alpha*(termV_Im - termW_Re);
            rhsIm[i] = Im[i] - alpha*(termV_Re + termW_Im);
        }
        
        const diagRe = new Float32Array(N);
        const diagIm = new Float32Array(N);
        const offRe = 0, offIm = -alpha * C;

        for(let i=0; i<N; i++) {
            diagRe[i] = 1 + alpha * W[i];
            diagIm[i] = alpha * (2*C + V[i]);
        }

        const c_prime_re = new Float32Array(N);
        const c_prime_im = new Float32Array(N);
        const d_prime_re = new Float32Array(N);
        const d_prime_im = new Float32Array(N);

        let denom = diagRe[0]**2 + diagIm[0]**2;
        c_prime_re[0] = (offRe*diagRe[0] + offIm*diagIm[0])/denom;
        c_prime_im[0] = (offIm*diagRe[0] - offRe*diagIm[0])/denom;
        d_prime_re[0] = (rhsRe[0]*diagRe[0] + rhsIm[0]*diagIm[0])/denom;
        d_prime_im[0] = (rhsIm[0]*diagRe[0] - rhsRe[0]*diagIm[0])/denom;

        for(let i=1; i<N; i++) {
            const ocp_re = offRe*c_prime_re[i-1] - offIm*c_prime_im[i-1];
            const ocp_im = offRe*c_prime_im[i-1] + offIm*c_prime_re[i-1];
            const piv_re = diagRe[i] - ocp_re;
            const piv_im = diagIm[i] - ocp_im;
            const piv_mag = piv_re**2 + piv_im**2;

            if(i < N-1) {
                c_prime_re[i] = (offRe*piv_re + offIm*piv_im)/piv_mag;
                c_prime_im[i] = (offIm*piv_re - offRe*piv_im)/piv_mag;
            }

            const odp_re = offRe*d_prime_re[i-1] - offIm*d_prime_im[i-1];
            const odp_im = offRe*d_prime_im[i-1] + offIm*d_prime_re[i-1];
            const num_re = rhsRe[i] - odp_re;
            const num_im = rhsIm[i] - odp_im;
            
            d_prime_re[i] = (num_re*piv_re + num_im*piv_im)/piv_mag;
            d_prime_im[i] = (num_im*piv_re - num_re*piv_im)/piv_mag;
        }

        const newRe = new Float32Array(N);
        const newIm = new Float32Array(N);
        newRe[N-1] = d_prime_re[N-1];
        newIm[N-1] = d_prime_im[N-1];

        for(let i=N-2; i>=0; i--) {
            const cx_re = c_prime_re[i]*newRe[i+1] - c_prime_im[i]*newIm[i+1];
            const cx_im = c_prime_re[i]*newIm[i+1] + c_prime_im[i]*newRe[i+1];
            newRe[i] = d_prime_re[i] - cx_re;
            newIm[i] = d_prime_im[i] - cx_im;
        }

        return [...newRe, ...newIm];
    },

    // Split-Operator Method (Spectral)
    splitOp: (t, psi, dt, p) => {
        const N = psi.length / 2;
        const re = psi.slice(0, N);
        const im = psi.slice(N, 2 * N);
        
        // Potential Step (V is Real Space)
        // psi = exp(-i V dt / 2) * psi
        const applyPot = (steps) => {
            for(let i=0; i<N; i++) {
                let V = p.V;
                // Absorbing Boundary (Imaginary Potential) handled in real space decay
                let decay = 1.0;
                if(p.bc === 'absorbing') {
                    const w = 20;
                    if(i < w) decay = Math.pow(i/w, 0.2);
                    else if(i > N-w) decay = Math.pow((N-i)/w, 0.2);
                }

                // Phase rotation due to V
                const theta = -V * dt * steps; 
                const c = Math.cos(theta), s = Math.sin(theta);
                const r = re[i], m = im[i];
                re[i] = (r*c - m*s) * decay;
                im[i] = (r*s + m*c) * decay;
            }
        };

        // 1. Half Kick
        applyPot(0.5);

        // 2. FFT to k-space
        Physics.fft(re, im, false);

        // 3. Kinetic Drift (k-space)
        // psi = exp(-i k^2/2 dt) * psi
        const dk = 2 * Math.PI / N;
        for(let i=0; i<N; i++) {
            let k = i;
            if (k > N/2) k -= N; // Aliasing
            k *= dk;
            const theta = -0.5 * k * k * dt;
            const c = Math.cos(theta), s = Math.sin(theta);
            const r = re[i], m = im[i];
            re[i] = r*c - m*s;
            im[i] = r*s + m*c;
        }

        // 4. IFFT to real space
        Physics.fft(re, im, true);

        // 5. Half Kick
        applyPot(0.5);

        return [...re, ...im];
    },

    euler: (t, y, dt, fn, p) => {
        const k1 = fn(t, y, p);
        return y.map((v, i) => v + k1[i] * dt);
    },
    rk4: (t, y, dt, fn, p) => {
        const k1 = fn(t, y, p);
        const y2 = y.map((v,i) => v + k1[i]*dt*0.5);
        const k2 = fn(t + dt*0.5, y2, p);
        const y3 = y.map((v,i) => v + k2[i]*dt*0.5);
        const k3 = fn(t + dt*0.5, y3, p);
        const y4 = y.map((v,i) => v + k3[i]*dt);
        const k4 = fn(t + dt, y4, p);
        return y.map((v,i) => v + (dt/6)*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));
    },
    // Runge-Kutta-Fehlberg 4(5) - Adaptive
    rk45: (t, y, dt, fn, p, tol=1e-5) => {
        const k1 = fn(t, y, p);
        const y2 = y.map((v,i) => v + dt*(1/4)*k1[i]);
        const k2 = fn(t+dt/4, y2, p);
        const y3 = y.map((v,i) => v + dt*((3/32)*k1[i] + (9/32)*k2[i]));
        const k3 = fn(t+3*dt/8, y3, p);
        const y4 = y.map((v,i) => v + dt*((1932/2197)*k1[i] - (7200/2197)*k2[i] + (7296/2197)*k3[i]));
        const k4 = fn(t+12*dt/13, y4, p);
        const y5 = y.map((v,i) => v + dt*((439/216)*k1[i] - 8*k2[i] + (3680/513)*k3[i] - (845/4104)*k4[i]));
        const k5 = fn(t+dt, y5, p);
        const y6 = y.map((v,i) => v + dt*((-8/27)*k1[i] + 2*k2[i] - (3544/2565)*k3[i] + (1859/4104)*k4[i] - (11/40)*k5[i]));
        const k6 = fn(t+dt/2, y6, p);

        const out5 = y.map((v,i) => v + dt*((16/135)*k1[i] + (6656/12825)*k3[i] + (28561/56430)*k4[i] - (9/50)*k5[i] + (2/55)*k6[i]));
        const out4 = y.map((v,i) => v + dt*((25/216)*k1[i] + (1408/2565)*k3[i] + (2197/4104)*k4[i] - (1/5)*k5[i]));

        let maxErr = 0;
        for(let i=0; i<y.length; i++) maxErr = Math.max(maxErr, Math.abs(out5[i]-out4[i]));
        
        let newDt = dt;
        if(maxErr > 0) newDt = 0.9 * dt * Math.pow(tol / maxErr, 0.2);
        newDt = Math.max(0.1*dt, Math.min(5.0*dt, newDt));
        
        return { y: out5, dt: newDt, err: maxErr };
    },
    symplectic: (t, y, dt, fn, p) => {
        const half = Math.floor(y.length / 2);
        const acc = fn(t, y, p);
        const next = [...y];
        // Symplectic Euler: v_{n+1} = v_n + a(x_n) * dt
        for(let i=0; i<half; i++) next[half+i] += acc[half+i] * dt;
        // x_{n+1} = x_n + v_{n+1} * dt
        for(let i=0; i<half; i++) next[i] += next[half+i] * dt;
        return next;
    },
    // Cubic Hermite Interpolated DDE Solver
    dde: (t, y, dt, hist, tau, fn, p) => {
        const target = t - tau;
        let y_lag = y;
        
        if(hist.length > 1 && tau > 0) {
            // Find segment
            let i = hist.length - 1;
            while (i > 0 && hist[i].t > target) i--;
            
            if (i >= 0 && i < hist.length - 1) {
                const h0 = hist[i], h1 = hist[i+1];
                // Normalized time in segment
                const theta = (target - h0.t) / (h1.t - h0.t);
                const dt_seg = h1.t - h0.t;
                
                // Hermite Basis
                const H00 = 2*theta**3 - 3*theta**2 + 1;
                const H10 = theta**3 - 2*theta**2 + theta;
                const H01 = -2*theta**3 + 3*theta**2;
                const H11 = theta**3 - theta**2;
                
                y_lag = h0.y.map((v, k) => {
                    // Derivatives scaled by dt
                    const m0 = h0.dy ? h0.dy[k] * dt_seg : 0; // fallback if dy missing
                    const m1 = h1.dy ? h1.dy[k] * dt_seg : 0;
                    return H00*v + H10*m0 + H01*h1.y[k] + H11*m1;
                });
            } else {
                // Out of history bounds, use linear extrapolation or clamp
                y_lag = hist[0].y; 
            }
        }
        
        const k1 = fn(t, y, y_lag, p);
        return { y: y.map((v,i) => v + k1[i]*dt), dy: k1 };
    },
    jacobianTrace: (y, fn, t, p) => {
        const eps = 1e-5; let trace = 0; const f0 = fn(t, y, p);
        for(let i=0; i<y.length; i++) {
            const y_p = [...y]; y_p[i] += eps;
            const f_p = fn(t, y_p, p);
            trace += (f_p[i] - f0[i]) / eps;
        }
        return trace;
    },
    eq: {
        lorenz: (t,s,p) => [p.s*(s[1]-s[0]), s[0]*(p.r-s[2])-s[1], s[0]*s[1]-p.b*s[2]],
        rossler: (t,s,p) => [-s[1]-s[2], s[0]+p.a*s[1], p.b+s[2]*(s[0]-p.c)],
        halvorsen: (t,s,p) => [ -p.a*s[0] - 4*s[1] - 4*s[2] - s[1]**2, -p.a*s[1] - 4*s[2] - 4*s[0] - s[2]**2, -p.a*s[2] - 4*s[0] - 4*s[1] - s[0]**2 ],
        thomas: (t,s,p) => [ Math.sin(s[1]) - p.b*s[0], Math.sin(s[2]) - p.b*s[1], Math.sin(s[0]) - p.b*s[2] ],
        chua: (t,s,p) => { 
            const h = p.m1*s[0] + 0.5*(p.m0-p.m1)*(Math.abs(s[0]+1)-Math.abs(s[0]-1));
            return [p.alpha*(s[1]-s[0]-h), s[0]-s[1]+s[2], -p.beta*s[1]];
        },
        rlc: (t,s,p) => [s[1], (p.V0*Math.sin(p.w*t) - p.R*s[1] - s[0]/p.C)/p.L], 
        duffing: (t,s,p) => [s[1], p.gam*Math.cos(p.w*t) - p.del*s[1] - p.alpha*s[0] - p.beta*Math.pow(s[0],3)],
        pendulum: (t,s,p) => {
            const [t1,w1,t2,w2]=s, d=2*p.m1+p.m2-p.m2*Math.cos(2*t1-2*t2);
            return [w1, (-p.g*(2*p.m1+p.m2)*Math.sin(t1)-p.m2*p.g*Math.sin(t1-2*t2)-2*Math.sin(t1-t2)*p.m2*(w2**2*p.l2+w1**2*p.l1*Math.cos(t1-t2)))/(p.l1*d), w2, (2*Math.sin(t1-t2)*(w1**2*p.l1*(p.m1+p.m2)+p.g*(p.m1+p.m2)*Math.cos(t1)+w2**2*p.l2*p.m2*Math.cos(t1-t2)))/(p.l2*d)];
        },
        nbody: (t,s,p) => {
            const acc=new Array(12).fill(0), G=1, m=[p.m,p.m,p.m];
            for(let i=0;i<3;i++){
                let ax=0,ay=0;
                for(let j=0;j<3;j++){
                    if(i===j)continue;
                    const dx=s[j*2]-s[i*2], dy=s[j*2+1]-s[i*2+1], r=Math.hypot(dx,dy)+0.05;
                    const f=G*m[j]/(r*r*r); ax+=f*dx; ay+=f*dy;
                }
                acc[6+i*2]=ax; acc[6+i*2+1]=ay;
            }
            return acc;
        },
        mackey: (t,s,l,p) => [p.beta * l[0] / (1 + Math.pow(l[0], p.n)) - p.gam * s[0]],
        // Quantum is now handled by crankNicolson/Split, this placeholder is unused
        quantum_dummy: (t, s, p) => [0],
        custom: (t,s,p) => [0,0,0]
    }
};

/* --- MODELS DATABASE --- */
const Models = [
    { cat: 'CHAOS', id: 'lorenz', sys: 'DISSIPATIVE', title: 'Lorenz Attractor', type: 'RK4', init: [0.1,0,0], fn: 'lorenz', p: k=>({s:10, b:8/3, r:k*100}), phases: [0,2], presets: [{n:'Chaos',k:0.28},{n:'Stable',k:0.1}], eq: '\\dot{x}=\\sigma(y-x)', desc: 'Simplified atmospheric convection model.', assump: ['Homogeneous fluid', 'Linear temperature profile'], valid: 'Rayleigh number near critical point.' },
    { cat: 'CHAOS', id: 'rossler', sys: 'DISSIPATIVE', title: 'Rössler Attractor', type: 'RK4', init: [0.1,0.1,0.1], fn: 'rossler', p: k=>({a:0.2, b:0.2, c:k*50}), phases: [0,1], eq: '\\dot{x}=-y-z', desc: 'Minimal chaotic system with one manifold.', assump: ['Theoretical construct'], valid: 'Topological chaos study.' },
    { cat: 'CHAOS', id: 'halvorsen', sys: 'DISSIPATIVE', title: 'Halvorsen Attractor', type: 'RK4', init: [1,0,0], fn: 'halvorsen', p: k=>({a:1.2+k*0.5}), phases: [0,1], eq: '\\dot{x} = -ax - 4y - 4z - y^2', desc: 'Cyclically symmetric attractor.', assump: ['Theoretical'], valid: 'Math curiosity.' },
    { cat: 'CHAOS', id: 'thomas', sys: 'DISSIPATIVE', title: 'Thomas Attractor', type: 'RK4', init: [0.1,0,0], fn: 'thomas', p: k=>({b:0.18 + k*0.05}), phases: [0,1], eq: '\\dot{x} = \\sin(y) - bx', desc: 'Cyclically symmetric chaotic attractor.', assump: ['Theoretical'], valid: 'Low dissipation chaos.' },
    
    { cat: 'CIRCUITS', id: 'rlc', sys: 'DRIVEN', title: 'RLC Series Circuit', type: 'RK4', energy: (s,p)=>0.5*s[0]*s[0]/p.C + 0.5*p.L*s[1]*s[1], init: [0.5, 0], fn: 'rlc', p: k=>({R:0.5, L:1, C:1, V0:1, w:1+k*2}), phases: [0,1], eq: 'L\\ddot{q} + R\\dot{q} + q/C = V(t)', desc: 'Damped driven harmonic oscillator in electronics.', assump: ['Ideal components', 'No radiation loss', 'Lumped parameters'], valid: 'Low frequency AC, non-microwave.' },
    { cat: 'CIRCUITS', id: 'chua', sys: 'DISSIPATIVE', title: 'Chua\'s Circuit', type: 'RK4', init: [0.1,0,0], fn: 'chua', p: k=>({alpha:15.6, beta:28+k, m0:-1.143, m1:-0.714}), phases: [0,1], eq: '\\dot{x}=\\alpha(y-x-f(x))', desc: 'Simplest electronic circuit exhibiting chaos.', assump: ['Piecewise-linear resistor', 'Ideal Inductor'], valid: 'Non-linear operational amplifier regime.' },

    { cat: 'OSCILLATOR', id: 'duffing', sys: 'DRIVEN', title: 'Duffing Oscillator', type: 'RK4', init: [0.1,0], fn: 'duffing', p: k=>({del:0.3, alpha:-1, beta:1, gam:0.5, w:1+k}), phases: [0,1], eq: '\\ddot{x} + \\delta\\dot{x} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t)', desc: 'Spring with non-linear restoring force.', assump: ['Point mass', 'Cubic stiffness'], valid: 'Large amplitude mechanical vibrations.' },
    { cat: 'MECH', id: 'pendulum', sys: 'HAMILTONIAN', title: 'Double Pendulum', type: 'SYMP', energy: (s,p)=>0, init: [2,0,2,0], fn: 'pendulum', p: k=>({m1:1, m2:1, l1:1, l2:1, g:9.8}), phases: [0,1], eq: '\\mathcal{L} = T - V', desc: 'Coupled pendulum showing Hamiltonian chaos.', assump: ['Massless rods', 'Frictionless pivots', 'Point masses'], valid: 'Classical mechanics domain.' },
    
    { cat: 'SPACE', id: 'nbody', sys: 'HAMILTONIAN', title: '3-Body Orbit', type: 'SYMP', energy: (s,p)=> {
         let T=0, V=0;
         const G=1, m=[p.m,p.m,p.m];
         for(let i=0;i<3;i++) T += 0.5*m[i]*(s[6+i*2]**2 + s[6+i*2+1]**2);
         for(let i=0;i<3;i++) for(let j=i+1;j<3;j++) V -= G*m[i]*m[j] / Math.hypot(s[j*2]-s[i*2], s[j*2+1]-s[i*2+1]);
         return T+V;
    }, init: [-1,0, 1,0, 0,1.7, 0.5,-0.5, 0.5,0.5, -1,0], fn: 'nbody', p: k=>({m:10}), phases: [0,1], eq: 'F = G m_1 m_2 / r^2', desc: 'Gravitational interaction of three bodies.', assump: ['Point masses', 'Newtonian gravity (No GR)'], valid: 'Non-relativistic speeds, weak fields.' },
    
    { cat: 'QM', id: 'quantum', sys: 'QUANTUM', title: 'Quantum Tunneling', type: 'SPLIT', init: [], fn: 'quantum_dummy', p: k=>({V:k*2, bc: App.state.numerics.bc}), phases: [0,1], eq: 'i\\hbar \\dot{\\psi} = \\hat{H} \\psi', desc: 'Wavefunction hitting a potential barrier.', assump: ['1D space', 'Non-relativistic', 'Time-independent potential'], valid: 'Schrödinger regime.' },
    { cat: 'DELAY', id: 'mackey', sys: 'DELAY', title: 'Mackey-Glass', type: 'DDE', init: [0.5], fn: 'mackey', p: k=>({beta:0.2, gam:0.1, n:10, tau:20}), phases: [0,0], eq: '\\dot{x} = \\beta x_{\\tau} / (1+x_{\\tau}^n) - \\gamma x', desc: 'Physiological feedback loop.', assump: ['Constant delay', 'Single variable feedback'], valid: 'biological control systems.' },
    { cat: 'CUSTOM', id: 'custom', sys: 'CUSTOM', title: 'Custom Equation', type: 'RK4', init: [1,1,1], fn: 'custom', p:k=>({}), phases: [0,1], eq: 'User Defined', desc: 'Live compilation of user equations.', assump: ['N/A'], valid: 'N/A' }
];

/* --- APP CONTROLLER --- */
const App = {
    state: { active: null, running: false, t: 0, y: [], aux: [], hist: [], traj: [], ensemble: [], dataLog: [], view: { zoom: 1, cx: 0, cy: 0, rotX: 0, rotY: 0 }, params: { k: 0.5, tau: 20, is3D: false, trails: true, glow: false }, numerics: { dt: 0.05, dir: 1, solver: 'RK4', ghosts: false, flow: false, bc: 'absorbing' }, ghostState: { euler: [], symp: [] }, input: { ptrs: new Map(), prevDist: 0 }, lyap: { sum: 0, n: 0 }, rec: { on: false }, audio: { on: false, ctx: null } },

    init() {
        this.populateMenu();
        this.setupInputs();
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.loadModel(Models[0]);
        this.initChart();
        requestAnimationFrame(() => this.loop());
    },

    populateMenu() {
        const l = document.getElementById('algo-list');
        const cats = {};
        Models.forEach(m => {
            if(!cats[m.cat]) {
                const h = document.createElement('h3');
                h.className = "text-[9px] font-bold opacity-40 mb-2 border-l-2 border-cyan-500 pl-2 tracking-widest mt-6 first:mt-0 uppercase";
                h.innerText = m.cat; l.appendChild(h); cats[m.cat] = true;
            }
            const b = document.createElement('button');
            b.className = "w-full text-left bg-white/5 border border-white/5 p-4 rounded mb-2 hover:border-cyan-500/30 transition flex justify-between items-center group active:bg-white/10";
            b.innerHTML = `<div><div class="font-bold text-xs group-hover:text-cyan-400 transition">${m.title}</div><div class="text-[9px] opacity-60 font-mono mt-0.5">${m.sys}</div></div><i class="fas fa-play text-[10px] opacity-20 group-hover:opacity-100 transition"></i>`;
            b.onclick = () => this.loadModel(m);
            l.appendChild(b);
        });
    },

    loadModel(m) {
        this.state.active = m;
        this.state.t = 0; this.state.running = true; 
        this.state.traj = []; this.state.hist = []; this.state.dataLog = [];
        this.state.ensemble = [];
        this.state.view = { zoom: 1, cx: 0, cy: 0, rotX: 0, rotY: 0 };
        this.state.lyap = { sum:0, n:0 };
        this.state.E0 = null; 
        
        // --- SMART SOLVER LOCKING ---
        const sel = document.getElementById('sel-solver');
        const lockMsg = document.getElementById('solver-lock-msg');
        Array.from(sel.options).forEach(o => o.disabled = false); // Reset
        lockMsg.classList.add('hidden');

        if(m.sys === 'HAMILTONIAN') {
            this.state.numerics.solver = 'VERLET'; // Default to Verlet
            sel.value = 'VERLET';
            Array.from(sel.options).forEach(o => { if(!['SYMP', 'VERLET', 'YOSHIDA'].includes(o.value)) o.disabled = true; });
            lockMsg.innerText = "LOCKED: SYMPLECTIC"; lockMsg.classList.remove('hidden');
        } else if(m.sys === 'DISSIPATIVE') {
            this.state.numerics.solver = 'RK4';
            sel.value = 'RK4';
            Array.from(sel.options).forEach(o => { if(!['RK4','RK45'].includes(o.value)) o.disabled = true; });
        } else if(m.sys === 'DELAY') {
            this.state.numerics.solver = 'DDE';
            sel.value = 'DDE';
            Array.from(sel.options).forEach(o => { if(o.value !== 'DDE') o.disabled = true; });
            lockMsg.innerText = "LOCKED: HERMITE DDE"; lockMsg.classList.remove('hidden');
        } else if(m.sys === 'QUANTUM') {
            this.state.numerics.solver = 'SPLIT';
            sel.value = 'SPLIT';
            Array.from(sel.options).forEach(o => { if(!['CN', 'SPLIT'].includes(o.value)) o.disabled = true; });
            lockMsg.innerText = "LOCKED: UNITARY/SPECTRAL"; lockMsg.classList.remove('hidden');
        }

        // Init State
        if(m.id === 'quantum') {
            const N = 256; // Power of 2 for FFT
            this.state.y = new Float32Array(N*2);
            // Gaussian Packet
            for(let i=0; i<N; i++) { 
                const x=(i-64)/10; 
                this.state.y[i] = Math.exp(-x*x)*Math.cos(5*x); 
                this.state.y[N+i] = Math.exp(-x*x)*Math.sin(5*x); 
            }
            // Normalize
            let norm = 0;
            for(let i=0; i<N; i++) norm += this.state.y[i]**2 + this.state.y[N+i]**2;
            norm = Math.sqrt(norm);
            for(let i=0; i<this.state.y.length; i++) this.state.y[i] /= norm;

        } else {
            this.state.y = [...m.init];
            this.state.ghostState.euler = [...m.init];
            this.state.ghostState.symp = [...m.init];
            if(['DISSIPATIVE', 'DRIVEN'].includes(m.sys)) {
                 this.state.shadow = this.state.y.map((v,i)=>i===0?v+1e-7:v);
            }
        }
        
        if(m.energy) this.state.E0 = m.energy(this.state.y, m.p(this.state.params.k));

        // Diagnostics UI Update
        document.getElementById('row-drift').classList.toggle('hidden', m.sys !== 'HAMILTONIAN');
        document.getElementById('row-div').classList.toggle('hidden', m.sys === 'QUANTUM');
        document.getElementById('row-lyap').classList.toggle('hidden', m.sys === 'QUANTUM' || m.sys === 'HAMILTONIAN');
        document.getElementById('row-norm').classList.toggle('hidden', m.sys !== 'QUANTUM');
        
        // Phase/Poincare Overlay
        const isAutonomous = ['CHAOS', 'MECH', 'SPACE'].includes(m.cat);
        const isDriven = m.sys === 'DRIVEN';
        
        document.getElementById('phase-disabled').classList.toggle('hidden', isAutonomous);
        document.getElementById('poincare-disabled').classList.toggle('hidden', isDriven);

        document.getElementById('sim-title').innerText = m.title;
        document.getElementById('info-heading').innerText = m.title;
        if(m.id !== 'custom') katex.render(m.eq, document.getElementById('katex-eq'), {throwOnError:false});
        else document.getElementById('katex-eq').innerText = "Defined by User Code";
        
        const ib = document.getElementById('info-body');
        ib.innerHTML = `
            <h3>Equation</h3><div class="font-mono text-cyan-200 mb-2 p-2 bg-black/30 rounded border border-white/5 text-[10px] overflow-x-auto">${m.eq}</div>
            <h3>System Type</h3><p class="text-cyan-400 font-bold">${m.sys}</p>
            <h3>Description</h3><p>${m.desc}</p>
            <h3>Assumptions</h3><ul>${m.assump.map(a=>`<li>${a}</li>`).join('')}</ul>
            <h3>Validity Domain</h3><p class="text-green-400">${m.valid}</p>
        `;

        document.getElementById('custom-panel').classList.toggle('hidden', m.id !== 'custom');
        document.getElementById('sel-bc').disabled = m.id !== 'quantum';
        
        const pc = document.getElementById('preset-container'); pc.innerHTML = '';
        if(m.presets) m.presets.forEach(p => {
            const b = document.createElement('button');
            b.className = "bg-white/10 px-2 py-1 rounded text-[9px] hover:bg-cyan-500/50 transition";
            b.innerText = p.n;
            b.onclick = () => { this.state.params.k = p.k; document.getElementById('inp-k').value = p.k; document.getElementById('lbl-k').innerText = p.k; this.showToast(`Loaded: ${p.n}`); };
            pc.appendChild(b);
        });

        ['phaseCanvas','poincareCanvas'].forEach(id=>this.clearCanvas(id));
        if(window.chart) { window.chart.data.labels=[]; window.chart.data.datasets[0].data=[]; window.chart.update(); }
        document.getElementById('data-body').innerHTML = '';

        document.getElementById('page-home').classList.add('hidden-left');
        document.getElementById('page-sim').classList.remove('hidden-right');
        document.getElementById('diag-order').innerText = this.state.numerics.solver;
        
        document.getElementById('lbl-phase-proj').innerText = m.phases ? `Axis ${m.phases[0]} vs ${m.phases[1]}` : "X vs Y";
    },

    compileCustom() {
        try {
            const code = document.getElementById('inp-code-custom').value;
            const type = document.getElementById('sel-custom-type').value;
            const fn = new Function('t', 's', 'p', code);
            Physics.eq.custom = fn;
            
            const m = Models.find(m=>m.id==='custom');
            m.sys = type; // Update system type for locking
            this.loadModel(m);
            this.showToast("Custom Model Compiled");
        } catch(e) { this.showToast("Error: " + e.message); }
    },

    spawnEnsemble() {
        if(!this.state.active || this.state.active.id === 'quantum') return;
        this.state.ensemble = [];
        for(let i=0; i<50; i++) {
            const perturbation = this.state.y.map(v => v + (Math.random()-0.5)*0.1);
            this.state.ensemble.push(perturbation);
        }
        this.showToast("Spawned 50 trajectories");
    },

    loop() {
        if(this.state.running && this.state.active) {
            let dt = this.state.numerics.dt * this.state.numerics.dir;
            const p = this.state.active.p(this.state.params.k);
            p.bc = this.state.numerics.bc; // Pass BC to quantum params
            if(this.state.active.sys === 'DELAY') p.tau = this.state.params.tau; // Enforce tau from slider for DDE

            let fn = Physics.eq[this.state.active.fn];
            let solver = this.state.numerics.solver;
            
            // Allow user override, but respect model constraints
            if(this.state.numerics.symm && this.state.active.id !== 'quantum' && this.state.active.type !== 'DDE') solver = 'MID';

            let currentErr = 0;
            let steps = 4;
            
            for(let s=0; s<steps; s++) {
                let res;
                // DDE Handling (Hermite)
                if(this.state.active.type === 'DDE' || solver === 'DDE') {
                    const tau = Math.max(0.1, p.tau);
                    // Push state + deriv to history
                    const deriv = fn(this.state.t, this.state.y, this.state.y, p); // Approx current deriv
                    this.state.hist.push({t:this.state.t, y:[...this.state.y], dy: deriv});
                    if(this.state.hist.length > 2000) this.state.hist.shift();
                    
                    const stepRes = Physics.dde(this.state.t, this.state.y, dt, this.state.hist, tau, fn, p);
                    res = { y: stepRes.y, err: 0 };
                }
                // Quantum Solvers
                else if(solver === 'CN') {
                    res = { y: Physics.crankNicolson(this.state.t, this.state.y, dt, p), err: 0 };
                }
                else if(solver === 'SPLIT') {
                    res = { y: Physics.splitOp(this.state.t, this.state.y, dt, p), err: 0 };
                }
                // Standard ODEs
                else if(solver === 'RK45') {
                    res = Physics.rk45(this.state.t, this.state.y, Math.abs(dt), fn, p);
                    this.state.y = res.y;
                    this.state.numerics.dt = res.dt; // Update global dt based on error
                    dt = res.dt * this.state.numerics.dir; 
                    document.getElementById('diag-dt').innerText = res.dt.toExponential(3);
                    currentErr = res.err;
                }
                else {
                    // Truncation Error check for fixed step methods (every few frames)
                    if(s === 0 && this.state.t % 0.1 < Math.abs(dt)) {
                        const y1 = Physics.rk4(this.state.t, this.state.y, dt, fn, p);
                        const y_half = Physics.rk4(this.state.t, this.state.y, dt/2, fn, p);
                        const y2 = Physics.rk4(this.state.t + dt/2, y_half, dt/2, fn, p);
                        let err = 0; for(let i=0;i<y1.length;i++) err += (y1[i]-y2[i])**2;
                        currentErr = Math.sqrt(err) / 15;
                        document.getElementById('diag-local').innerText = currentErr.toExponential(2);
                        document.getElementById('diag-dt').innerText = Math.abs(dt).toFixed(3);
                    }
                    
                    if(solver === 'SYMP') this.state.y = Physics.symplectic(this.state.t, this.state.y, dt, fn, p);
                    else if(solver === 'VERLET') this.state.y = Physics.velocityVerlet(this.state.t, this.state.y, dt, fn, p);
                    else if(solver === 'YOSHIDA') this.state.y = Physics.yoshida(this.state.t, this.state.y, dt, fn, p);
                    else this.state.y = Physics.rk4(this.state.t, this.state.y, dt, fn, p);
                }

                this.state.y = res && res.y ? res.y : this.state.y;

                // Quantum Unitarity Check
                if(this.state.active.sys === 'QUANTUM') {
                    let norm = 0; const N = this.state.y.length/2;
                    for(let i=0; i<N; i++) norm += this.state.y[i]**2 + this.state.y[N+i]**2;
                    norm = Math.sqrt(norm);
                    document.getElementById('val-norm').innerText = norm.toFixed(6);
                }

                // Data Logging for PDF (Buffer limited to 2000)
                if(s===0) {
                    this.state.dataLog.push({t:this.state.t, y:[...this.state.y], err: currentErr});
                    if(this.state.dataLog.length > 2000) this.state.dataLog.shift();
                }

                // Ensemble Integration
                if(this.state.ensemble.length > 0) {
                    for(let i=0; i<this.state.ensemble.length; i++) {
                        this.state.ensemble[i] = Physics.rk4(this.state.t, this.state.ensemble[i], dt, fn, p);
                    }
                }

                // Energy Drift
                if(this.state.active.energy && this.state.E0) {
                    const E = this.state.active.energy(this.state.y, p);
                    const drift = Math.abs((E - this.state.E0)/this.state.E0);
                    document.getElementById('diag-drift').innerText = (drift*100).toFixed(4) + "%";
                }
                
                // Jacobian & Lyapunov (Metric Stability)
                if(this.state.active.sys === 'DISSIPATIVE') {
                    const div = Physics.jacobianTrace(this.state.y, fn, this.state.t, p);
                    document.getElementById('val-div').innerText = div.toFixed(4);

                    // Lyapunov Shadow (Benettin)
                    if(this.state.shadow && s===0) {
                        this.state.shadow = Physics.rk4(this.state.t, this.state.shadow, dt, fn, p);
                        let d = Math.hypot(...this.state.y.map((v,i)=>v-this.state.shadow[i]));
                        if(d > 0) {
                            this.state.lyap.sum += Math.log(d/1e-7); this.state.lyap.n++;
                            document.getElementById('val-lyap').innerText = (this.state.lyap.sum / (this.state.lyap.n*dt)).toFixed(3);
                            // Rescale
                            this.state.shadow = this.state.y.map((v,i) => v + (this.state.shadow[i]-v)*(1e-7/d));
                        }
                    }
                }
            }

            this.state.t += dt;
            this.updateAudio(this.state.y[0]||0);

            // Buffering for Visuals
            let pt = {x:0, y:0, z:0};
            if(this.state.active.id === 'nbody') {
                pt.bodies = [{x:this.state.y[0],y:this.state.y[1]}, {x:this.state.y[2],y:this.state.y[3]}, {x:this.state.y[4],y:this.state.y[5]}];
            } else if(this.state.active.id === 'pendulum') {
                const x1=Math.sin(this.state.y[0]), y1=Math.cos(this.state.y[0]);
                pt = {x: x1+Math.sin(this.state.y[2]), y: y1+Math.cos(this.state.y[2]), z:0};
            } else {
                pt = {x:this.state.y[0], y:this.state.y[1], z:this.state.y[2]||0};
            }

            if(!pt.bodies && this.state.active.id !== 'quantum') {
                this.state.traj.push(pt);
                if(this.state.traj.length > 600) this.state.traj.shift();
            }

            if(this.state.t % 0.1 < Math.abs(dt)) {
                this.updateGraph(this.state.y[0]||0);
                this.updateTable();
                this.updatePhase();
                this.updatePoincare();
                this.computeFFT();
            }
        }
        this.render();
        requestAnimationFrame(() => this.loop());
    },

    render() {
        const cvs = document.getElementById('simCanvas');
        const ctx = cvs.getContext('2d');
        const w = cvs.width, h = cvs.height;

        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
        ctx.fillRect(0,0,w,h);

        ctx.save();
        ctx.translate(w/2 + this.state.view.cx, h/2 + this.state.view.cy);
        const scale = this.state.view.zoom * (this.state.params.is3D ? 1 : (this.state.active.id==='nbody'?30:10));
        ctx.scale(scale, scale);

        const proj = (x,y,z) => {
            if(!this.state.params.is3D) return {x:x*10, y:-y*10};
            const yaw = this.state.view.rotX * Math.PI/180;
            const pitch = this.state.view.rotY * Math.PI/180;
            let x1 = x*Math.cos(yaw) - z*Math.sin(yaw);
            let z1 = x*Math.sin(yaw) + z*Math.cos(yaw);
            let y2 = y*Math.cos(pitch) - z1*Math.sin(pitch);
            let z2 = y*Math.sin(pitch) + z1*Math.cos(pitch);
            const s = 500/(500+z2); 
            return {x: x1*s*10, y: -y2*s*10};
        };

        // Render Vector Field (Flow)
        if(this.state.numerics.flow && this.state.active.id !== 'quantum' && this.state.active.id !== 'nbody') {
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath();
            const fn = Physics.eq[this.state.active.fn];
            const p = this.state.active.p(this.state.params.k);
            const step = 2; // Grid spacing
            const range = 20;
            for(let x=-range; x<=range; x+=step) {
                for(let y=-range; y<=range; y+=step) {
                    const dv = fn(0, [x,y,0], p);
                    const mag = Math.hypot(dv[0], dv[1]) + 0.001;
                    const p1 = proj(x,y,0);
                    const p2 = proj(x + dv[0]/mag, y + dv[1]/mag, 0);
                    ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                }
            }
            ctx.stroke();
        }

        // Render Ensemble
        if(this.state.ensemble.length > 0) {
            ctx.fillStyle = 'rgba(250, 204, 21, 0.4)';
            for(let i=0; i<this.state.ensemble.length; i++) {
                const s = this.state.ensemble[i];
                let p = proj(s[0], s[1], s[2]||0);
                if(this.state.active.id==='pendulum') {
                    const x1=Math.sin(s[0]), y1=Math.cos(s[0]);
                    p = proj(x1+Math.sin(s[2]), y1+Math.cos(s[2]), 0);
                }
                ctx.beginPath(); ctx.arc(p.x, p.y, 2/scale, 0, 6.28); ctx.fill();
            }
        }

        // Render Ghosts
        if(this.state.numerics.ghosts && this.state.active.id !== 'nbody') {
            const ge = this.state.ghostState.euler;
            const pe = proj(ge[0], ge[1], ge[2]||0);
            ctx.fillStyle = 'rgba(255,0,0,0.5)'; ctx.beginPath(); ctx.arc(pe.x, pe.y, 4/scale, 0, 6.28); ctx.fill();
            
            const gs = this.state.ghostState.symp;
            const ps = proj(gs[0], gs[1], gs[2]||0);
            ctx.fillStyle = 'rgba(0,255,0,0.5)'; ctx.beginPath(); ctx.arc(ps.x, ps.y, 4/scale, 0, 6.28); ctx.fill();
        }

        ctx.strokeStyle = '#06b6d4';
        ctx.lineWidth = 2/scale;
        if(this.state.params.glow) { ctx.shadowBlur = 15; ctx.shadowColor = '#06b6d4'; }

        if(this.state.active.id === 'quantum') {
            const N = this.state.y.length/2;
            ctx.beginPath();
            for(let i=0; i<N; i++) {
                const mag = Math.sqrt(this.state.y[i]**2 + this.state.y[N+i]**2);
                const p = proj((i-64)*0.5, mag*5, 0);
                i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            // Draw Barrier
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            const b1 = proj(25, -2, 0), b2 = proj(30, -2, 0);
            ctx.fillRect(b1.x, -1000/scale, b2.x-b1.x, 2000/scale);
        }
        else if(this.state.active.id === 'nbody') {
            const cols = ['#06b6d4', '#e879f9', '#facc15'];
            if(this.state.params.trails) {
                for(let b=0; b<3; b++) {
                    ctx.strokeStyle = cols[b]; ctx.beginPath();
                    for(let i=0; i<this.state.traj.length; i+=2) {
                        if(!this.state.traj[i].bodies) continue;
                        const p = proj(this.state.traj[i].bodies[b].x, this.state.traj[i].bodies[b].y, 0);
                        i===0?ctx.moveTo(p.x,p.y):ctx.lineTo(p.x,p.y);
                    }
                    ctx.stroke();
                }
            }
            for(let b=0; b<3; b++) {
                const p = proj(this.state.y[b*2], this.state.y[b*2+1], 0);
                ctx.fillStyle = cols[b]; ctx.beginPath(); ctx.arc(p.x, p.y, 8/scale, 0, 6.28); ctx.fill();
            }
        }
        else {
            if(this.state.traj.length > 1) {
                ctx.beginPath();
                for(let i=0; i<this.state.traj.length; i++) {
                    const t = this.state.traj[i]; if(t.bodies) continue;
                    const p = proj(t.x, t.y, t.z);
                    i===0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
            }
            if(this.state.traj.length) {
                const last = this.state.traj[this.state.traj.length-1];
                if(!last.bodies) {
                    const p = proj(last.x, last.y, last.z);
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.x, p.y, 4/scale, 0, 6.28); ctx.fill();
                }
            }
        }
        ctx.restore();
    },

    setupInputs() {
        const c = document.getElementById('simCanvas');
        c.addEventListener('pointerdown', e => {
            c.setPointerCapture(e.pointerId);
            this.state.input.ptrs.set(e.pointerId, {x:e.clientX, y:e.clientY});
            if(this.state.input.ptrs.size === 2) {
                const p = [...this.state.input.ptrs.values()];
                this.state.input.prevDist = Math.hypot(p[0].x-p[1].x, p[0].y-p[1].y);
                document.getElementById('gesture-hint').style.opacity = 1;
            }
        });
        c.addEventListener('pointermove', e => {
            if(!this.state.input.ptrs.has(e.pointerId)) return;
            const old = this.state.input.ptrs.get(e.pointerId);
            if(this.state.input.ptrs.size === 1) {
                const dx = e.clientX - old.x, dy = e.clientY - old.y;
                if(this.state.params.is3D) { this.state.view.rotX += dx * 0.5; this.state.view.rotY += dy * 0.5; document.getElementById('inp-rotX').value = this.state.view.rotX % 360; } 
                else { this.state.view.cx += dx; this.state.view.cy += dy; }
            } else if(this.state.input.ptrs.size === 2) {
                this.state.input.ptrs.set(e.pointerId, {x:e.clientX, y:e.clientY});
                const p = [...this.state.input.ptrs.values()];
                const dist = Math.hypot(p[0].x-p[1].x, p[0].y-p[1].y);
                const delta = dist - this.state.input.prevDist;
                this.state.view.zoom *= (1 + delta * 0.005);
                this.state.input.prevDist = dist;
                document.getElementById('inp-zoom').value = this.state.view.zoom;
            }
            this.state.input.ptrs.set(e.pointerId, {x:e.clientX, y:e.clientY});
        });
        c.addEventListener('pointerup', e => { this.state.input.ptrs.delete(e.pointerId); if(this.state.input.ptrs.size < 2) document.getElementById('gesture-hint').style.opacity = 0; });
        
        document.getElementById('inp-k').oninput = e => { this.state.params.k = parseFloat(e.target.value); document.getElementById('lbl-k').innerText = e.target.value; };
        document.getElementById('inp-3d').onchange = e => this.state.params.is3D = e.target.checked;
        document.getElementById('inp-rotX').oninput = e => this.state.view.rotX = parseFloat(e.target.value);
        document.getElementById('inp-zoom').oninput = e => this.state.view.zoom = parseFloat(e.target.value);
        document.getElementById('inp-glow').onchange = e => this.state.params.glow = e.target.checked;
        document.getElementById('inp-dt').oninput = e => { this.state.numerics.dt = parseFloat(e.target.value); document.getElementById('lbl-dt').innerText = e.target.value; };
    },

    toggleCinema() {
        const isCinema = document.body.classList.toggle('cinema-mode');
        if(isCinema) {
            if(document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(() => console.warn("Fullscreen blocked"));
            }
            this.showToast("Tap screen to exit");
            document.getElementById('simCanvas').addEventListener('click', () => this.toggleCinema(), {once:true});
        } else {
            if(document.fullscreenElement) document.exitFullscreen().catch(()=>{});
        }
    },
    
    toggleDrawer() { 
        const d=document.getElementById('drawer'); 
        const isUp = d.style.transform === 'translateY(0px)' || d.style.transform === '';
        d.style.transform = isUp ? 'translateY(85%)' : 'translateY(0px)';
    },

    setTab(id) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelector(`button[data-tab="${id}"]`).classList.add('active');
        ['controls','numerics','phase','poincare','graph','bifur','fft','data','info'].forEach(t => document.getElementById('tab-'+t).classList.add('hidden'));
        document.getElementById('tab-'+id).classList.remove('hidden');
        this.resize();
    },

    // Numerics Controls
    setDirection(d) { 
        this.state.numerics.dir = d; 
        document.getElementById('btn-fwd').className = d===1 ? "px-2 py-1 bg-cyan-600 rounded text-white" : "bg-white/10 px-2 py-1 rounded";
        document.getElementById('btn-bwd').className = d===-1 ? "px-2 py-1 bg-cyan-600 rounded text-white" : "bg-white/10 px-2 py-1 rounded";
    },
    toggleSymm() {
        this.state.numerics.symm = !this.state.numerics.symm;
        document.getElementById('btn-sym').className = this.state.numerics.symm ? "px-2 py-1 bg-purple-600 rounded text-white" : "bg-white/10 px-2 py-1 rounded";
        this.showToast(this.state.numerics.symm ? "Symplectic Enforced" : "Standard Mode");
    },
    setBC(val) { this.state.numerics.bc = val; },
    setSolver(val) { this.state.numerics.solver = val; document.getElementById('diag-order').innerText = val; },
    toggleGhosts() { this.state.numerics.ghosts = document.getElementById('chk-ghosts').checked; },
    toggleFlow() { this.state.numerics.flow = document.getElementById('chk-flow').checked; },
    
    runDtSweep() {
        if(!this.state.active) return;
        const resDiv = document.getElementById('sweep-result');
        resDiv.classList.remove('hidden'); resDiv.innerText = "Computing convergence...";
        
        setTimeout(() => {
            const steps = [0.1, 0.05, 0.025, 0.0125];
            const errs = [];
            const T = 5;
            const fn = Physics.eq[this.state.active.fn];
            const p = this.state.active.p(this.state.params.k);
            let y_ref = [...this.state.active.init];
            let dt_ref = 0.001;
            // Ref run
            if(this.state.active.id === 'quantum') { resDiv.innerText="N/A for Quantum"; return; }
            for(let t=0; t<T; t+=dt_ref) y_ref = Physics.rk4(t, y_ref, dt_ref, fn, p);
            
            steps.forEach(dt => {
                let y = [...this.state.active.init];
                for(let t=0; t<T; t+=dt) y = Physics.rk4(t, y, dt, fn, p);
                let err = 0;
                for(let i=0; i<y.length; i++) err += (y[i]-y_ref[i])**2;
                errs.push(Math.sqrt(err));
            });
            resDiv.innerHTML = `DT SWEEP (Error @ T=${T}):<br>dt=0.1: ${errs[0].toExponential(1)}<br>dt=0.01: ${errs[3].toExponential(1)}<br>Converges as O(dt^${(Math.log(errs[0]/errs[3])/Math.log(0.1/0.0125)).toFixed(1)})`;
        }, 50);
    },
    
    runReversibility() {
        const y_start = [...this.state.y];
        const steps = 100;
        const dt = this.state.numerics.dt;
        const fn = Physics.eq[this.state.active.fn];
        const p = this.state.active.p(this.state.params.k);
        let y = [...y_start];
        for(let i=0; i<steps; i++) y = Physics.rk4(0, y, dt, fn, p);
        for(let i=0; i<steps; i++) y = Physics.rk4(0, y, -dt, fn, p);
        let diff = 0; for(let i=0; i<y.length; i++) diff += (y[i]-y_start[i])**2;
        this.showToast(`Reversibility Err: ${Math.sqrt(diff).toExponential(2)}`);
    },

    updateGraph(val) { if(!window.chart) return; window.chart.data.labels.push(this.state.t.toFixed(1)); window.chart.data.datasets[0].data.push(val); if(window.chart.data.labels.length>50) { window.chart.data.labels.shift(); window.chart.data.datasets[0].data.shift(); } if(!document.getElementById('tab-graph').classList.contains('hidden')) window.chart.update('none'); },
    updateTable() { if(document.getElementById('tab-data').classList.contains('hidden')) return; const b = document.getElementById('data-body'); const r = document.createElement('tr'); r.innerHTML = `<td class="p-3 opacity-50 font-mono">${this.state.t.toFixed(2)}</td><td class="text-cyan-400 font-bold">${(this.state.y[0]||0).toFixed(3)}</td><td class="text-pink-400">${(this.state.y[1]||0).toFixed(3)}</td><td class="text-white/50">${(this.state.y[2]||0).toFixed(3)}</td><td class="text-red-400 text-[8px]">${(this.state.dataLog[this.state.dataLog.length-1]?.err||0).toExponential(1)}</td>`; b.prepend(r); if(b.children.length>20) b.lastChild.remove(); },
    updatePhase() { 
        if(document.getElementById('tab-phase').classList.contains('hidden')) return;
        if(['DRIVEN', 'DELAY'].includes(this.state.active.sys)) return; // Disable for Driven/Delay
        const ctx = document.getElementById('phaseCanvas').getContext('2d'); const w = ctx.canvas.width; const idx1=this.state.active.phases?.[0]||0; const idx2=this.state.active.phases?.[1]||1; ctx.fillStyle = 'rgba(168, 85, 247, 0.5)'; ctx.fillRect(w/2 + this.state.y[idx1]*10, w/2 - this.state.y[idx2]*10, 2, 2); 
    },
    updatePoincare() { 
        if(document.getElementById('tab-poincare').classList.contains('hidden')) return; 
        if(this.state.active.sys !== 'DRIVEN') return; // Only for Driven

        const p = this.state.active.p(this.state.params.k);
        const w_drive = p.w || 1;
        const T = 2 * Math.PI / w_drive;
        
        // Strobing logic: t approx n*T
        // Check if we crossed a period boundary in this step
        const dt = this.state.numerics.dt;
        const phase = this.state.t % T;
        
        if(phase < dt) { 
            const ctx = document.getElementById('poincareCanvas').getContext('2d'); 
            const w = ctx.canvas.width; 
            ctx.fillStyle = '#f97316'; 
            ctx.fillRect(w/2 + this.state.y[0]*10, w/2 - this.state.y[1]*10, 3, 3); 
        } 
    },
    
    computeFFT() {
        if(document.getElementById('tab-fft').classList.contains('hidden')) return;
        
        // Calculate and display Nyquist
        const dt = this.state.numerics.dt;
        const nyquist = 1 / (2 * dt);
        document.getElementById('lbl-nyquist').innerText = nyquist.toFixed(1);

        const data = this.state.traj.map(p => p.bodies ? p.bodies[0].x : p.x); // Support NBody
        const N = data.length; 
        // Windowing (Power of 2 for potential FFT optim, though we use naive DFT here for short segments)
        if(N < 64) return;
        
        const spectrum = []; const K = 32; 
        for(let k=0; k<K; k++) {
            let re=0, im=0;
            for(let n=0; n<N; n++) { const theta = -2*Math.PI*k*n/N; re += data[n] * Math.cos(theta); im += data[n] * Math.sin(theta); }
            spectrum.push(Math.sqrt(re*re + im*im));
        }
        const max = Math.max(...spectrum) || 1;
        const cont = document.getElementById('fft-bars'); cont.innerHTML = '';
        spectrum.forEach(v => { const h = (v/max)*100; const bar = document.createElement('div'); bar.className = 'flex-1 bg-pink-500/80 hover:bg-pink-400'; bar.style.height = `${h}%`; cont.appendChild(bar); });
    },
    
    runBifurcation() { 
        const cvs = document.getElementById('bifurCanvas'); const ctx = cvs.getContext('2d'); const w=cvs.clientWidth; const h=cvs.clientHeight; cvs.width=w; cvs.height=h;
        ctx.fillStyle='black'; ctx.fillRect(0,0,w,h); document.getElementById('bifur-overlay').classList.remove('hidden'); 
        setTimeout(() => { 
            ctx.fillStyle = '#4ade80'; const fn = Physics.eq[this.state.active.fn]; let p;
            for(let i=0; i<w; i+=2) {
                const k = i/w; p = this.state.active.p(k);
                let s = [...this.state.active.init];
                // Burn transient
                for(let t=0; t<500; t++) s = Physics.rk4(0, s, 0.05, fn, p);
                let prevX = s[0];
                for(let t=0; t<100; t++) {
                    s = Physics.rk4(0, s, 0.05, fn, p); const currX = s[0];
                    if(t>1 && currX < prevX) ctx.fillRect(i, h/2 - prevX*5, 1.5, 1.5);
                    prevX = currX;
                }
            }
            document.getElementById('bifur-overlay').classList.add('hidden'); 
        }, 100); 
    },
    
    exportCSV() { let c = "Time,X,Y,Z\n"; this.state.dataLog.forEach(p => c += `${p.t.toFixed(2)},${p.y[0]},${p.y[1]},${p.y[2]||0}\n`); const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([c], {type:'text/csv'})); a.download = 'data.csv'; a.click(); },
    
    exportPDF() { 
        if(!window.jspdf) { this.showToast("PDF Lib not ready"); return; }
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        doc.setFontSize(18); doc.setTextColor(0, 150, 200);
        doc.text(`Simulation Report: ${this.state.active.title}`, 14, 20);
        doc.setFontSize(10); doc.setTextColor(0,0,0);
        doc.text(`Generated: ${new Date().toLocaleString()}`, 14, 28);
        doc.text(`Model: ${this.state.active.eq}`, 14, 34);
        
        const canvas = document.getElementById('simCanvas');
        const imgData = canvas.toDataURL("image/jpeg", 0.7);
        doc.addImage(imgData, 'JPEG', 14, 40, 180, 100);

        if(doc.autoTable) {
            const rows = this.state.dataLog.map(d => [d.t.toFixed(2), d.y[0].toFixed(4), d.y[1].toFixed(4), (d.y[2]||0).toFixed(4), (d.err||0).toExponential(1)]);
            doc.autoTable({ head: [["Time", "X", "Y", "Z", "Error"]], body: rows, startY: 150, styles: { fontSize: 8, font: "courier" }, headStyles: { fillColor: [0, 150, 200] } });
        }
        doc.save("FDE_Report.pdf"); 
    },
    
    toggleRec() { if(!this.state.rec.on) { try { const s = document.getElementById('simCanvas').captureStream(30); this.state.rec.media = new MediaRecorder(s); this.state.rec.chunks = []; this.state.rec.media.ondataavailable = e => this.state.rec.chunks.push(e.data); this.state.rec.media.onstop = () => { const blob = new Blob(this.state.rec.chunks, {type:'video/webm'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'sim.webm'; a.click(); }; this.state.rec.media.start(); this.state.rec.on = true; document.getElementById('rec-dot').classList.remove('hidden'); this.showToast("Recording..."); } catch(e) { this.showToast("Not Supported"); } } else { this.state.rec.media.stop(); this.state.rec.on = false; document.getElementById('rec-dot').classList.add('hidden'); this.showToast("Saved"); } },
    togglePause() { this.state.running = !this.state.running; document.getElementById('play-btn').innerHTML = this.state.running ? '<i class="fas fa-pause text-xs"></i>' : '<i class="fas fa-play text-xs"></i>'; },
    toggleAudio() { 
        if(!this.state.audio.ctx) { const A=window.AudioContext||window.webkitAudioContext; this.state.audio.ctx=new A(); this.state.audio.osc=this.state.audio.ctx.createOscillator(); this.state.audio.gain=this.state.audio.ctx.createGain(); this.state.audio.osc.connect(this.state.audio.gain); this.state.audio.gain.connect(this.state.audio.ctx.destination); this.state.audio.osc.start(); this.state.audio.gain.gain.value=0; } 
        this.state.audio.on = !this.state.audio.on; this.showToast(this.state.audio.on?"Audio ON":"Audio OFF"); 
    },
    updateAudio(v) { if(this.state.audio.on) { this.state.audio.osc.frequency.setTargetAtTime(200+Math.abs(v)*100, this.state.audio.ctx.currentTime, 0.1); this.state.audio.gain.gain.setTargetAtTime(0.1, this.state.audio.ctx.currentTime, 0.1); } else if(this.state.audio.ctx) { this.state.audio.gain.gain.setTargetAtTime(0, this.state.audio.ctx.currentTime, 0.1); } },
    
    goBack() { this.state.running=false; document.getElementById('page-home').classList.remove('hidden-left'); document.getElementById('page-sim').classList.add('hidden-right'); },
    clearCanvas(id) { const c=document.getElementById(id); if(c) c.getContext('2d').clearRect(0,0,c.width,c.height); },
    showToast(msg) { const t=document.getElementById('toast'); document.getElementById('toast-msg').innerText=msg; t.style.opacity=1; setTimeout(()=>t.style.opacity=0, 2000); },
    resize() { ['simCanvas','phaseCanvas','poincareCanvas','graphCanvas','bifurCanvas'].forEach(id => { const el = document.getElementById(id); if(el && el.offsetParent) { el.width = el.clientWidth; el.height = el.clientHeight; } }); },
    initChart() { const ctx = document.getElementById('graphCanvas').getContext('2d'); window.chart = new Chart(ctx, { type: 'line', data: { labels: [], datasets: [{ label: 'Val', data: [], borderColor: '#06b6d4', borderWidth: 2, pointRadius: 0 }] }, options: { responsive: true, maintainAspectRatio: false, animation: false, scales: { x: {display:false}, y: {grid:{color:'rgba(255,255,255,0.05)'}} }, plugins: { legend: {display:false} } } }); }
};

App.init();
    // --- PWA SERVICE WORKER REGISTRATION ---
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js')
                .then(registration => {
                    console.log('ServiceWorker registration successful');
                })
                .catch(err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
        });
    }
</script>
</body>
</html>



